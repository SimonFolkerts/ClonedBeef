$(document).ready(function () {

    //Editor contents
    var contents = [];

//########## Step One
    contents[0] = ['function startGame() {\r\n    myGameArea.start();\r\n} \n \nvar myGameArea = {\r\n    canvas : document.getElementById("gameArea"),\r\n    start : function() {\r\n        this.canvas.width = 480;\r\n        this.canvas.height = 320; \r\n        this.context = this.canvas.getContext(\"2d);\");\r\n    }\r\n};', 'javascript'];
    
//########## Step Two
    contents[1] = ['function startGame() {\r\n    myGameArea.start();\r\n    myGamePiece = new component(30, 30, \"black\", 10, 120);\r\n}\n\nfunction component(width, height, color, x, y) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.x = x;\r\n    this.y = y;\r\n    ctx = myGameArea.context;\r\n    ctx.fillstyle = color;\r\n    ctx.fillRect(this.x, this.y, this.width, this.height);\r\n}', 'javascript'];
    
//########## Step Three
    contents[2] = ['var myGameArea = {\r\n    start : function() {\r\n        //existing code \n        this.interval = setInterval(updateGameArea, 20);\r\n    },\r\n    clear : function() {\r\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n};\n\nfunction component(width, height, color, x, y) {\n    //existing code\n    this.update = function(){\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = color;\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n    };\n}\n\nfunction updateGameArea() {\r\n    myGameArea.clear();\r\n    myGamePiece.update();\r\n\n    \/\/counter logic\r\n    if (count <= 50) {\r\n        count++;\r\n    } else {\r\n        count = 0;\r\n    }\r\n    $(\'#count-2\').html(count);\r\n}\r\n\r\n    var count = 0;\r\n}', 'javascript'];
    
//########## Step Four
    contents[3] = ['function startGame() {\r\n    myGameArea.start();\r\n    myGamePiece = new component(30, 30, \"black\", 10, 120);\r\n}\r\n\r\nvar myGameArea = {\r\n    start: function () {\r\n        this.canvas = document.getElementById(\'canvas-step-\' + (step - 1));\r\n        this.canvas.width = 480;\r\n        this.canvas.height = 320;\r\n        this.context = this.canvas.getContext(\"2d\");\r\n        this.interval = setInterval(updateGameArea, 20);\r\n    },\r\n    clear: function () {\r\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n};\r\n\r\nfunction component(width, height, color, x, y) {\r\n    this.width = width;\r\n    this.height = height;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.update = function () {\r\n        ctx = myGameArea.context;\r\n        ctx.fillstyle = color;\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n    };\r\n}\r\n\r\nfunction updateGameArea() {\r\n    myGameArea.clear();\r\n    myGamePiece.update();\r\n}\r\n\r\nstartGame();', 'javascript'];

//########## Step Five
    contents[4] = ['function component(width, height, color, x, y) {\n    //existing code\n    this.newPos = function() {\r\n        this.x += targetX;\r\n        this.y += targetY; \r\n        };\n}\n\nfunction component(width, height, color, x, y) {\n    start: function () {\n        //existing code\n        this.mouseX = 0;\r\n        this.mouseY = 0;\r\n        this.canvas.addEventListener(\"mousemove\", function (event) {\r\n            myGameArea.mouseX = event.offsetX;\r\n            myGameArea.mouseY = event.offsetY;\r\n        });\r\n    }\n}\n\nfunction updateGameArea() {\r\n        myGameArea.clear();\r\n        myGamePiece.newPos(myGameArea.mouseX, myGameArea.mouseY);\r\n        myGamePiece.update();\r\n}', 'javascript'];
    
//########## Step Six
    contents[5] = ['function startGame() {\r\n    myGamePiece = new component(30, 30, \"black\", 20, 120, 15, 100);\r\n}\n\nfunction component(width, height, color, x, y, accel, speed) {\r\n    \/\/existing code\r\n    this.acceleration = accel;\r\n    this.maxSpeed = speed;\r\n    \r\n    this.newPos = function (targetY) {\r\n        \/\/ X direction removed, myGamePiece will only move vertically\r\n        this.y += (clamp((targetY - this.y), -this.maxSpeed, this.maxSpeed)) \/ this.acceleration;\r\n    };\r\n}\r\n\r\nfunction clamp(num, min, max) {\r\n    return num <= min ? min : num >= max ? max : num;\r\n}\r\n\r\nfunction updateGameArea() {\r\n    \/\/existing code\r\n    myGamePiece.newPos(myGameArea.mouseY);\r\n}', 'javascript'];
    
//########## Step Seven
    contents[6] = ['function startGame() {\r\n    myGamePiece = new playerCharacter(30, 30, \"black\", 20, 120, 15, 100);\r\n    enemyPiece = new enemyBasic(30, 30, \"red\", 490, (Math.random() * 300), 0, 0);\r\n}\r\n\r\nfunction playerCharacter(width, height, color, x, y, accel, speed) {\r\n    \/\/existing code\r\n    this.active = true;\r\n}\r\n\r\nfunction enemyBasic(width, height, color, x, y, accel, speed) {\r\n    \/\/existing code\r\n    this.active = true;\r\n    this.update = function () {\r\n        \/\/existing code\r\n        if (this.x <= 0) {\r\n            this.active = false;\r\n        }\r\n    };\r\n    this.newPos = function () {\r\n        this.x += -3;\r\n    };\r\n}\r\n\r\nfunction updateGameArea() {\r\n    myGameArea.clear();\r\n\r\n    if ((Math.random() * 1000) > 990) {\r\n         enemyPiece = new enemyBasic(30, 30, \"red\", 490, (Math.random() * 320), 0, 0);\r\n    }\r\n\r\n    if (enemyPiece.active) {\r\n        enemyPiece.update();\r\n        enemyPiece.newPos();\r\n    }\r\n\r\n    myGamePiece.newPos(myGameArea.mouseY);\r\n    myGamePiece.update();\r\n}', 'javascript'];

//########## Step Eight
    contents[7] = ['var myGameArea = {\r\n    start: function () {\r\n        this.enemies = [];\r\n        \/\/existing code\r\n    }\r\n};\r\n\r\nfunction updateGameArea() {\r\n    myGameArea.clear();\r\n        \r\n    if ((Math.random() * 1000) > 990) {\r\n         myGameArea.enemies.push(new enemyBasic(30, 30, \"red\", 490, (Math.random() * 280), 0, 0));\r\n    }\r\n    \r\n    $(myGameArea.enemies).each(function() {\r\n        this.newPos();\r\n        this.update();\r\n    });\r\n    \r\n    myGameArea.enemies = myGameArea.enemies.filter(function(enemyBasic) {\r\n        return enemyBasic.active;\r\n    });\r\n        \r\n    myGamePiece.newPos(myGameArea.mouseY);\r\n    myGamePiece.update();\r\n}', 'javascript'];

//########## Step Nine
    contents[8] = ['$(\"#canvas-step-\" + step).click(function () {\r\n    if (!myGameArea.canvas) {\r\n        startGame();\r\n    } else if (!myGameArea.active) {\r\n        myGameArea.interval = setInterval(updateGameArea, 20);\r\n        myGameArea.active = true;\r\n    }\r\n});\r\n\r\n$(window).blur(function () {\r\n    myGameArea.stop();\r\n});\r\n\r\nvar myGameArea = {\r\n    start: function () {\r\n        this.active = true;\r\n        \/\/existing code\r\n    },\r\n    \/\/existing code\r\n    stop: function () {\r\n        clearInterval(this.interval);\r\n        this.active = false;\r\n    }\r\n};\r\n\r\nfunction collision(a, b) {\r\n    return a.x < b.x + b.width &&\r\n            a.x + a.width > b.x &&\r\n            a.y < b.y + b.height &&\r\n            a.y + a.height > b.y;\r\n}\r\n\r\nfunction collisionHandler() {\r\n    $(myGameArea.enemies).each(function () {\r\n        if (collision(myGamePiece, this)) {\r\n            myGameArea.stop();\r\n        }\r\n    });\r\n}\r\n\r\nfunction updateGameArea() {\r\n    collisionHandler();\r\n    \/\/existing code\r\n}', 'javascript'];

//########## Step Ten
    contents[9] = ['\r\nvar count = 0;\r\nvar step = 9;\r\n\r\n$(\"#canvas-step-\" + step).click(function () {\r\n    if (!myGameArea.canvas) {\r\n        startGame();\r\n    } else if (!myGameArea.active) {\r\n        myGameArea.interval = setInterval(updateGameArea, 20);\r\n        myGameArea.active = true;\r\n    }\r\n});\r\n$(window).blur(function () {\r\n    myGameArea.stop();\r\n});\r\n\r\nfunction startGame() {\r\n    myGameArea.start();\r\n    myGamePiece = new playerCharacter(30, 30, \"black\", 20, 120, 15, 100);\r\n    enemyPiece = new enemyBasic(30, 30, \"red\", 490, (Math.random() * 280), 0, 0);\r\n}\r\n\r\nvar myGameArea = {\r\n    start: function () {\r\n        this.active = true;\r\n        this.enemies = [];\r\n        this.canvas = document.getElementById(\'canvas-step-\' + (step));\r\n        this.canvas.width = 480;\r\n        this.canvas.height = 320;\r\n        this.context = this.canvas.getContext(\"2d\");\r\n        this.interval = setInterval(updateGameArea, 20);\r\n        this.mouseX = 0;\r\n        this.mouseY = 0;\r\n        this.canvas.addEventListener(\"mousemove\", function (event) {\r\n            myGameArea.mouseX = event.offsetX;\r\n            myGameArea.mouseY = event.offsetY;\r\n        });\r\n    },\r\n    clear: function () {\r\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    },\r\n    stop: function () {\r\n        clearInterval(this.interval);\r\n        this.active = false;\r\n    }\r\n};\r\n\r\nfunction playerCharacter(width, height, color, x, y, accel, speed) {\r\n    this.active = true;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.acceleration = accel;\r\n    this.maxSpeed = speed;\r\n    this.update = function () {\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = color;\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n    };\r\n    this.newPos = function (targetY) {\r\n        this.y += (clamp((targetY - this.y), -this.maxSpeed, this.maxSpeed)) \/ this.acceleration;\r\n    };\r\n}\r\n\r\nfunction enemyBasic(width, height, color, x, y, accel, speed) {\r\n    this.active = true;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.acceleration = accel;\r\n    this.maxSpeed = speed;\r\n    this.update = function () {\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = color;\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        if (this.x <= 0) {\r\n            this.active = false;\r\n        }\r\n    };\r\n    this.newPos = function () {\r\n        this.x += -3;\r\n    };\r\n}\r\n\r\nfunction clamp(num, min, max) {\r\n    return num <= min ? min : num >= max ? max : num;\r\n}\r\n\r\nfunction collision(a, b) {\r\n    return a.x < b.x + b.width &&\r\n            a.x + a.width > b.x &&\r\n            a.y < b.y + b.height &&\r\n            a.y + a.height > b.y;\r\n}\r\n\r\nfunction collisionHandler() {\r\n    $(myGameArea.enemies).each(function () {\r\n        if (collision(myGamePiece, this)) {\r\n            myGameArea.stop();\r\n        }\r\n    });\r\n}\r\n\r\nfunction updateGameArea() {\r\n    collisionHandler();\r\n    myGameArea.clear();\r\n\r\n    if ((Math.random() * 1000) > 990) {\r\n        myGameArea.enemies.push(new enemyBasic(30, 30, \"red\", 490, (Math.random() * 280), 0, 0));\r\n    }\r\n\r\n    $(myGameArea.enemies).each(function () {\r\n        this.newPos();\r\n        this.update();\r\n    });\r\n\r\n    myGameArea.enemies = myGameArea.enemies.filter(function (enemyBasic) {\r\n        return enemyBasic.active;\r\n    });\r\n\r\n    myGamePiece.newPos(myGameArea.mouseY);\r\n    myGamePiece.update();\r\n}', 'javascript'];

//########## Step Eleven
    contents[10] = ['var myGameArea = {\r\n    start: function () {\r\n        \/\/existing code\r\n        this.playerMissiles = [];\r\n        this.canvas.addEventListener(\"click\", function () {\r\n                myGameArea.playerMissiles.push(new playerMissile(myGamePiece.x, myGamePiece.y, myGameArea.mouseX, myGameArea.mouseY));\r\n        });\r\n    }\r\n}\r\n\r\nfunction playerMissile(x, y, targetX, targetY) {\r\n    this.active = true;\r\n    this.width = 15;\r\n    this.height = 15;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.velocityX;\r\n    this.velocityY;\r\n    this.acceleration = 0.3;\r\n    this.thrust = 0;\r\n    this.targetX = targetX;\r\n    this.targetY = targetY;\r\n    this.update = function () {\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = \"blue\";\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        if (Math.abs(this.x - this.targetX) < 10) {\r\n            this.active = false;\r\n        }\r\n    };\r\n    this.newPos = function () {\r\n        var tx = this.targetX - this.x;\r\n        var ty = this.targetY - this.y;\r\n        var dist = Math.sqrt(tx * tx + ty * ty);\r\n\r\n        this.thrust = this.thrust + this.acceleration;\r\n\r\n        this.velocityX = (tx \/ dist) * this.thrust;\r\n        this.velocityY = (ty \/ dist) * this.thrust;\r\n\r\n        this.x += this.velocityX;\r\n        this.y += this.velocityY;\r\n    };\r\n}\r\n\r\nfunction collisionHandler() {\r\n    $(myGameArea.enemies).each(function () {\r\n        enemy = this;\r\n        if (collision(myGamePiece, enemy)) {\r\n            myGameArea.stop();\r\n        }\r\n        $(myGameArea.playerMissiles).each(function () {\r\n            if (collision(enemy, this)) {\r\n                enemy.active = false;\r\n                this.active = false;\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nfunction updateGameArea() {\r\n    myGameArea.clear();\r\n\r\n    myGamePiece.newPos(myGameArea.mouseY);\r\n    myGamePiece.update();\r\n\r\n    if ((Math.random() * 1000) > 990) {\r\n        myGameArea.enemies.push(new enemyBasic(30, 30, \"red\", 490, (Math.random() * 280), 0, 0));\r\n    }\r\n\r\n    myGameArea.enemies = myGameArea.enemies.filter(function (enemyBasic) {\r\n        return enemyBasic.active;\r\n    });\r\n\r\n    $(myGameArea.enemies).each(function () {\r\n        this.newPos();\r\n        this.update();\r\n    });\r\n\r\n    myGameArea.playerMissiles = myGameArea.playerMissiles.filter(function (playerMissile) {\r\n        return playerMissile.active;\r\n    });\r\n\r\n    $(myGameArea.playerMissiles).each(function () {\r\n        this.newPos();\r\n        this.update();\r\n    });\r\n    collisionHandler();\r\n}', 'javascript']

//########## Step Twelve
    contents[11] = ['var myGameArea = {\r\n    start: function () {\r\n       \/\/existing code\r\n        this.frameNo = 0;\r\n        this.mouseDown = false;\r\n        this.canvas.addEventListener(\"mousedown\", function () {\r\n            myGameArea.mouseDown = true;\r\n        });\r\n        this.canvas.addEventListener(\"mouseup\", function () {\r\n            myGameArea.mouseDown = false;\r\n        });\r\n    }\r\n   \/\/existing code\r\n};\r\n\r\nfunction playerCharacter(width, height, color, x, y, accel, speed) {\r\n   \/\/existing code\r\n    this.color = color;\r\n    this.targets = [];\r\n    this.i = 0;\r\n    this.update = function () {\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        this.fireControl();\r\n    };\r\n    this.fireControl = function () {\r\n        if (!myGameArea.mouseDown && this.targets.length >= 1) {\r\n            if (this.i <= this.targets.length && (myGameArea.frameNo % 3 === 0)) {\r\n                this.i = 0;\r\n                this.fire(this.targets[this.i]);\r\n                this.targets.splice(this.i, 1);\r\n                this.i++;\r\n            }\r\n        }\r\n    };\r\n   \/\/existing code\r\n    this.fire = function (target) {\r\n        myGameArea.playerMissiles.push(new playerMissile(myGamePiece.x, myGamePiece.y, target));\r\n    };\r\n}\r\n\r\nfunction enemyBasic(width, height, color, x, y, accel, speed) {\r\n   \/\/existing code\r\n    this.color = color;\r\n    this.targeted = false;\r\n    this.speed = speed;\r\n    this.update = function () {\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = this.color;\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        if (this.x <= -20) {\r\n            this.active = false;\r\n        }\r\n        if (mouseOver(this) && !this.targeted) {\r\n            if (myGameArea.mouseDown) {\r\n                this.targeted = true;\r\n                this.color = \'yellow\';\r\n                myGamePiece.targets.push(this);\r\n            }\r\n        }\r\n    };\r\n    this.newPos = function () {\r\n        this.x += this.speed;\r\n    };\r\n}\r\n\r\nfunction playerMissile(x, y, target) {\r\n   \/\/existing code\r\n    this.age = 0;\r\n    this.target = target;\r\n    this.update = function () {\r\n        this.age++;\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = \"blue\";\r\n        ctx.fillRect(this.x, this.y, this.width, this.height);\r\n        if (Math.abs(this.x - this.targetX) < 8 || this.age > 75) {\r\n            this.active = false;\r\n        }\r\n    };\r\n   \/\/existing code\r\n}\r\n\r\nfunction mouseOver(object) {\r\n    return myGameArea.mouseX < object.x + object.width &&\r\n            myGameArea.mouseX > object.x &&\r\n            myGameArea.mouseY < object.y + object.height &&\r\n            myGameArea.mouseY > object.y;\r\n}\r\n\r\nfunction updateGameArea() {\r\n    myGameArea.frameNo++;\r\n    if ((Math.random() * 1000) > (990 - myGameArea.frameNo \/ 100)) {\r\n        myGameArea.enemies.push(new enemyBasic(30, 30, \"red\", 490, (Math.random() * 280), 0, 0));\r\n    }\r\n}', 'javascript']

//########## Step Thirteen
    contents[12] = ['function playerMissile(x, y, target) {\r\n    \/\/existing code\r\n    this.update = function() {\r\n        this.age++;\r\n        this.getAngle();\r\n        ctx = myGameArea.context;\r\n        ctx.save();\r\n        ctx.translate(this.x, this.y);\r\n        ctx.rotate(this.angle);\r\n        ctx.fillStyle = \"blue\";\r\n        ctx.fillRect(0, 0, this.width, this.height);\r\n        ctx.restore();\r\n        if (this.age > 75) {\r\n            this.active = false;\r\n        }\r\n        myGameArea.exhausts.push(new exhaust(this.x, this.midpoint().y, this.angle));\r\n    };\r\n    this.getAngle = function() {\r\n        var x = this.x - (this.target.midpoint().x);\r\n        var y = this.y - (this.target.midpoint().y);\r\n        this.angle = (Math.atan2(y, x)) - Math.PI;\r\n    };\r\n}\r\n\r\nfunction exhaust(x, y, angle) {\r\n    this.active = true;\r\n    this.age = 0;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.midpoint = function() {\r\n        return {\r\n            x: this.x - this.width \/ 2,\r\n            y: this.y - this.height \/ 2\r\n        };\r\n    };\r\n    this.velocityX;\r\n    this.velocityY;\r\n    this.acceleration = -0.1;\r\n    this.thrust = (Math.random() * 3) + 5;\r\n    this.angle = (Math.random() * 0.25) + angle - Math.PI;\r\n    this.lifetime = 50;\r\n    this.update = function() {\r\n        this.age++;\r\n        this.draw();\r\n        this.fadeEffect();\r\n    };\r\n    this.fadeEffect = function() {\r\n        this.width = (20 * (this.age \/ this.lifetime)) + 5;\r\n        this.height = (20 * (this.age \/ this.lifetime)) + 5;\r\n        if (this.x < 0 || this.age > this.lifetime) {\r\n            this.active = false;\r\n        }\r\n    };\r\n    this.draw = function() {\r\n        ctx = myGameArea.context;\r\n        ctx.fillStyle = \"#999999\";\r\n        ctx.globalAlpha = 1 - (this.age \/ (this.lifetime + 1));\r\n        ctx.fillRect(this.midpoint().x, this.midpoint().y, this.width, this.height);\r\n        ctx.globalAlpha = 1.0;\r\n    };\r\n    this.newPos = function() {\r\n        this.thrust = this.thrust + this.acceleration;\r\n\r\n        this.velocityX = Math.cos(this.angle) * this.thrust;\r\n        this.velocityY = Math.sin(this.angle) * this.thrust;\r\n\r\n        this.x += this.velocityX - 1;\r\n        this.y += this.velocityY;\r\n    };\r\n}\r\n\r\nfunction crosshair(x, y, width, height, parent) {\r\n    this.age = 0;\r\n    this.active = true;\r\n    this.width = width;\r\n    this.height = height;\r\n    this.x = x;\r\n    this.y = y;\r\n    this.color = \'#00EE00\';\r\n    this.parent = parent;\r\n    this.angle = 0;\r\n    this.midpoint = function() {\r\n        return {\r\n            x: this.x - this.width \/ 2,\r\n            y: this.y - this.height \/ 2\r\n        };\r\n    };\r\n    this.update = function() {\r\n        this.age++;\r\n        if (this.width > 45 & this.age > 5) {\r\n            this.width -= 10;\r\n            this.height -= 10;\r\n        }\r\n        if (!this.parent.tracked) {\r\n            this.color = \'#00EE00\';\r\n            this.angle -= 0.1;\r\n        } else {\r\n            this.flashLockBox();\r\n        }\r\n        ctx = myGameArea.context;\r\n        ctx.save();\r\n        ctx.translate(this.parent.midpoint().x, this.parent.midpoint().y);\r\n        ctx.rotate(this.angle);\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeRect(0 - this.width \/ 2, 0 - this.height \/ 2, this.width, this.height);\r\n        ctx.restore();\r\n        if (!this.parent.active) {\r\n            this.active = false;\r\n        }\r\n    };\r\n    this.flashLockBox = function() {\r\n        this.angle = 0;\r\n        if (this.age % 4 === 0 && this.width <= 45) {\r\n            if (this.color === \'red\') {\r\n                this.color = \'transparent\';\r\n            } else {\r\n                this.color = \'red\';\r\n            }\r\n        }\r\n    };\r\n    this.newPos = function() {\r\n        this.x = this.parent.midpoint().x;\r\n        this.y = this.parent.midpoint().y;\r\n    };\r\n}','javascript'];
    
//########## Step Fourteen
    contents[13] = ['\/\/an example of the code used to enable the drawing of sprites \r\n\/\/by setting the color property to transparent, the box is no longer drawn\r\n\r\nthis.update = function () {\r\n            \/\/existing code\r\n            this.index = Math.floor(clamp(((this.y - gameArea.mouseY) \/ 13 + 15), 0, 29));\r\n};\r\n\r\nthis.draw = function () {\r\n            ctx = gameArea.context;\r\n            ctx.fillStyle = this.color;  \/\/set this to transparent as box no longer needed\r\n            ctx.fillRect(this.x, this.y, this.width, this.height);\r\n            gameArea.context.drawImage(\r\n                    this.image,\r\n                    (this.index * this.srcWidth),\r\n                    0,\r\n                    this.srcWidth,\r\n                    this.srcHeight,\r\n                    this.x + this.offsetX,\r\n                    this.y + this.offsetY,\r\n                    this.destWidth,\r\n                    this.destHeight);\r\n};\r\n\r\nthis.image = new Image();\r\nthis.image.src = \'..\/img\/ship_sprite_sheet.png\';\r\nthis.offsetX = 0;\r\nthis.offsetY = -15;\r\nthis.srcWidth = 100;\r\nthis.srcHeight = 90;\r\nthis.index = 15;\r\nthis.destWidth = this.srcWidth \/ 1.5;\r\nthis.destHeight = this.srcHeight \/ 1.5;','javascript'];

//########## Step Fifteen
    contents[14] = ['var gameArea = {\r\n    start: function () {\r\n        \/\/existing code\r\n        this.getMousePos = function (mouseEvent) {\r\n            var rect = this.canvas.getBoundingClientRect();\r\n            gameArea.mouseX = mouseEvent.clientX - rect.left;\r\n            gameArea.mouseY = mouseEvent.clientY - rect.top;\r\n        };\r\n        this.getTouchPos = function (touchEvent) {\r\n            var rect = this.canvas.getBoundingClientRect();\r\n            gameArea.mouseX = touchEvent.touches[0].clientX - rect.left;\r\n            gameArea.mouseY = touchEvent.touches[0].clientY - rect.top;\r\n            if (event.target === gameArea.canvas) {\r\n                event.preventDefault();\r\n            }\r\n        };\r\n        this.canvas.addEventListener(\"touchmove\", function (event) {\r\n            gameArea.getTouchPos(event);\r\n            cursor.active = false;\r\n        });\r\n        this.canvas.addEventListener(\"mousemove\", function (event) {\r\n            gameArea.getMousePos(event);\r\n            cursor.active = true;\r\n        });\r\n        this.canvas.addEventListener(\"touchstart\", function (event) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            gameArea.getTouchPos(event);\r\n            if (gameArea.terminate) {\r\n                gameArea.start();\r\n            }\r\n            gameArea.mouseDown = true;\r\n            cursor.active = false;\r\n        });\r\n        this.canvas.addEventListener(\"mousedown\", function () {\r\n            if (gameArea.terminate) {\r\n                gameArea.start();\r\n            }\r\n            gameArea.mouseDown = true;\r\n            cursor.active = true;\r\n        });\r\n        [\'mouseup\', \'touchend\'].forEach(function (event) {\r\n            gameArea.canvas.addEventListener(event, function () {\r\n                gameArea.mouseDown = false;\r\n            });\r\n        });\r\n    }\r\n}','javascript'];

//########## Step Sixteen
    contents[15] = ['(function () {\r\n\r\n\/\/ INIT ============================================================================\r\n    var canvas = document.getElementById(\'canvas\');\r\n    \r\n    $(\'#canvas, #modal, #playbutton\').on(\'tap click\', function (event) {\r\n        event.preventDefault();\r\n        if (!gameArea.canvas) {\r\n            $(\'#modal\').addClass(\'hidden\');\r\n            showSplash(canvas);\r\n            loadAssets();\r\n            $(canvas).addClass(\'no-cursor\');\r\n        } else if (!gameArea.active) {\r\n            gameArea.interval = setInterval(updateGameArea, 20);\r\n            gameArea.active = true;\r\n            $(canvas).addClass(\'no-cursor\');\r\n        }\r\n    });\r\n    $(window).on(\'tap click\', function (event) {\r\n        if (!gameArea.canvas) {\r\n            return null;\r\n        } else if (event.target !== gameArea.canvas && gameArea.active) {\r\n            gameArea.pause();\r\n            $(\'#canvas\').removeClass(\'no-cursor\');\r\n        }\r\n    });\r\n\/\/  these event listeners trigger the setup\/pausing\/unpausing of the game\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n\/\/  \r\n    function showSplash(target) {\r\n        target.width = settings.canvasWidth;\r\n        target.height = settings.canvasHeight;\r\n        var ctx = target.getContext(\'2d\');\r\n        ctx.font = \'20px Arial\';\r\n        ctx.fillText(\'LOADING ASSETS...\', 10, 30, 400);\r\n    }\r\n\/\/  this function displays a loading screen\r\n\/\/  --------------------------------------------------------------------------------   \r\n\r\n\r\n    function loadAssets() {\r\n        \/\/player ship\r\n        assetPool.playerShipImg.src = playerShipProperties.image;\r\n        \/\/player missile\r\n        assetPool.playerMissileImg.src = playerMissileProperties.image;\r\n        \/\/enemyBasic\r\n        assetPool.enemyBasicImg.src = enemyBasicProperties.image;\r\n        \/\/explosion\r\n        assetPool.explosionImg.src = explosionProperties.image;\r\n        \/\/background\r\n        assetPool.backgroundImg.src = \'..\/img\/background.jpg\';\r\n        \/\/cursor\r\n        assetPool.cursorImg.src = cursorProperties.image;\r\n    }\r\n\/\/  this function specifies the files to load for each asset\r\n\/\/  --------------------------------------------------------------------------------\r\n\r\n\r\n    var assetPool = new function () {\r\n        this.playerShipImg = new Image();\r\n        this.playerMissileImg = new Image();\r\n        this.enemyBasicImg = new Image();\r\n        this.explosionImg = new Image();\r\n        this.backgroundImg = new Image();\r\n        this.cursorImg = new Image();\r\n\r\n        this.loadedAssets = 0;\r\n        this.assets = [\r\n            this.playerShipImg,\r\n            this.playerMissileImg,\r\n            this.enemyBasicImg,\r\n            this.explosionImg,\r\n            this.backgroundImg\r\n        ];\r\n        this.assets.forEach(function (asset) {\r\n            asset.onload = function () {\r\n                assetPool.checkAssetsLoaded();\r\n            };\r\n        });\r\n        this.checkAssetsLoaded = function () {\r\n            assetPool.loadedAssets++;\r\n            if (assetPool.loadedAssets === assetPool.assets.length) {\r\n                startGame();\r\n            }\r\n        };\r\n    };\r\n\/\/  this object initialises the assets for each object that needs one, and assigns\r\n\/\/  an event listener to each asset to determine when it is loaded. When all assets are loaded \r\n\/\/  it triggers the start of the game loop\r\n\r\n\r\n    function startGame() {\r\n        gameArea.start();\r\n        playerShip = new playerShip(40, 120, playerShipProperties);\r\n        cursor = new cursor(0, 0, cursorProperties);\r\n    }\r\n\/\/  this function calls the necessary methods and functions to set up the game world\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n\r\n\/\/  OBJECTS AND OBJECT CONSTRUCTORS ================================================\r\n\r\n    var gameArea = {\r\n        start: function () {\r\n            this.active = true;\r\n            this.terminate = false;\r\n\r\n            this.enemies = [];\r\n            this.playerMissiles = [];\r\n            this.explodyBits = [];\r\n            this.exhausts = [];\r\n            this.crosshairs = [];\r\n            this.explosions = [];\r\n            this.entities = [\r\n                [this.enemies],\r\n                [this.playerMissiles],\r\n                [this.explodyBits],\r\n                [this.exhausts],\r\n                [this.crosshairs],\r\n                [this.explosions]\r\n            ];\r\n            this.frameNo = 0;\r\n            this.canvas = document.getElementById(\'canvas\');\r\n            this.canvas.width = settings.canvasWidth;\r\n            this.canvas.height = settings.canvasHeight;\r\n            $(this.canvas).css(\'background-color\', settings.canvasColor);\r\n            this.context = this.canvas.getContext(\"2d\");\r\n            this.interval = setInterval(updateGameArea, settings.interval);\r\n            this.mouseX = 0;\r\n            this.mouseY = 0;\r\n            this.mouseDown = false;\r\n            this.score = 0;\r\n\r\n            this.bgImg = assetPool.backgroundImg;\r\n            this.bgCounter = 0;\r\n\r\n            this.canvas.addEventListener(\"touchmove\", function (event) {\r\n                gameArea.getTouchPos(event);\r\n                cursor.visible = false;\r\n            });\r\n            this.canvas.addEventListener(\"mousemove\", function (event) {\r\n                gameArea.getMousePos(event);\r\n                cursor.visible = true;\r\n            });\r\n            this.canvas.addEventListener(\"touchstart\", function (event) {\r\n                event.preventDefault();\r\n                event.stopPropagation();\r\n                gameArea.getTouchPos(event);\r\n                if (gameArea.terminate) {\r\n                    gameArea.start();\r\n                }\r\n                gameArea.mouseDown = true;\r\n                cursor.visible = false;\r\n            });\r\n            this.canvas.addEventListener(\"mousedown\", function (event) {\r\n                event.preventDefault(); \/\/to prevent text on page highlighting if spamming click\r\n                if (gameArea.terminate) {\r\n                    gameArea.start();\r\n                }\r\n                gameArea.mouseDown = true;\r\n                cursor.visible = true;\r\n            });\r\n            [\'mouseup\', \'touchend\'].forEach(function (event) {\r\n                gameArea.canvas.addEventListener(event, function () {\r\n                    gameArea.mouseDown = false;\r\n                });\r\n            });\r\n        },\r\n        getMousePos: function (mouseEvent) {\r\n            var rect = this.canvas.getBoundingClientRect();\r\n            gameArea.mouseX = Math.round(mouseEvent.clientX) - rect.left;\r\n            gameArea.mouseY = Math.round(mouseEvent.clientY) - rect.top;\r\n        },\r\n        getTouchPos: function (touchEvent) {\r\n            var rect = this.canvas.getBoundingClientRect();\r\n            gameArea.mouseX = touchEvent.touches[0].clientX - rect.left;\r\n            gameArea.mouseY = touchEvent.touches[0].clientY - rect.top;\r\n            if (event.target === gameArea.canvas) {\r\n                event.preventDefault();\r\n            }\r\n        },\r\n        background: function () {\r\n            if (this.bgCounter < 615) {\r\n                this.bgCounter++;\r\n            } else {\r\n                this.bgCounter = 0;\r\n            }\r\n            this.context.drawImage(this.bgImg, 0, 0, this.bgImg.width, 320, 0 - this.bgCounter, 0, this.bgImg.width, 320);\r\n        },\r\n        clear: function () {\r\n            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        },\r\n        pause: function () {\r\n            clearInterval(this.interval);\r\n            this.active = false;\r\n            this.updateScore();\r\n        },\r\n        stop: function () {\r\n            clearInterval(this.interval);\r\n            this.active = false;\r\n            this.terminate = true;\r\n            this.killEntities();\r\n        },\r\n        killEntities: function () {\r\n            playerShip.targetsLocked = [];\r\n            this.entities.forEach(function (entityList) {\r\n                entityList.forEach(function (entity) {\r\n                    if (entity.active) {\r\n                        entity.active = false;\r\n                    }\r\n                });\r\n            });\r\n        },\r\n        updateScore: function () {\r\n            ctx = gameArea.context;\r\n            ctx.font = \"20px Arial\";\r\n            ctx.fillStyle = \'black\';\r\n            if (!this.active && !this.terminate) {\r\n                ctx.fillText(this.score + \' - PAUSED\', 5, 20);\r\n            } else {\r\n                ctx.fillText(this.score, 5, 20);\r\n            }\r\n        }\r\n    };\r\n\/\/  this object stores the game state and objects and contains the functionality \r\n\/\/  necesary to initialize, interface with and update\/display the game world.\r\n\/\/  ----- methods:\r\n\/\/  start()         - initialise the game area\r\n\/\/  getMousePos()   - get the mouse position\r\n\/\/  getTouchPos()   - get touch position\r\n\/\/  background()    - adjust and draw the background\r\n\/\/  clear()         - empty the canvas\r\n\/\/  pause()         - halt the game, preserving state\r\n\/\/  stop()          - halt the game, initiate cleanup\r\n\/\/  killEntities()  - set all extant active objects to inactive\r\n\/\/  updateScore()   - update the score readout\r\n\/\/  --------------------------------------------------------------------------------   \r\n\r\n\r\n    function component(x, y, params) {\r\n        if (!params) {\r\n            console.log(\'no object data passed\');\r\n        }\r\n        \/\/basic attributes\r\n        this.active = params.active;\r\n        this.age = 0;\r\n        \/\/position and dimension info\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = params.width;\r\n        this.height = params.height;\r\n        this.topLeftBoundary = function () {\r\n            \/\/this determines the top left coordinate\r\n            \/\/of the entity for collision detection\r\n            return {\r\n                x: this.x - this.width \/ 2,\r\n                y: this.y - this.height \/ 2\r\n            };\r\n        };\r\n        this.topLeftSprite = function () {\r\n            \/\/this determines the top left coordinate\r\n            \/\/of the entity for drawing\r\n            return {\r\n                x: this.x - this.destWidth \/ 2,\r\n                y: this.y - this.destHeight \/ 2\r\n            };\r\n        };\r\n        this.rotate = params.rotate;\r\n        this.angle = params.angle;\r\n        \/\/bounding box info\r\n        this.color = params.color;\r\n        \/\/rendering info\r\n        this.offsetX = params.offsetX;\r\n        this.offsetY = params.offsetY;\r\n        this.srcWidth = params.srcWidth;\r\n        this.srcHeight = params.srcHeight;\r\n        this.index = params.index;\r\n        this.destWidth = this.srcWidth * params.rescaleX;\r\n        this.destHeight = this.srcHeight * params.rescaleY;\r\n        \/\/draw bounding box\r\n        this.drawBox = function () {\r\n            \/\/this function checks if rotation is enabled for this object, and if so,\r\n            \/\/runs the code necessary to draw the rotated image. Otherwise is skips the\r\n            \/\/save\/rotate\/restore actions to improve performance and merely draws a rect\r\n            ctx = gameArea.context;\r\n            if (this.rotate) {\r\n                ctx.save();\r\n                ctx.translate(this.x, this.y);\r\n                ctx.rotate(this.angle);\r\n                ctx.fillStyle = this.color;\r\n                ctx.fillRect(\r\n                        -this.width \/ 2,\r\n                        -this.height \/ 2,\r\n                        this.width,\r\n                        this.height);\r\n                ctx.restore();\r\n            } else {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fillRect(\r\n                        this.topLeftBoundary().x,\r\n                        this.topLeftBoundary().y,\r\n                        this.width,\r\n                        this.height);\r\n            }\r\n        };\r\n        \/\/draw sprite\r\n        this.drawSprite = function () {\r\n            \/\/this function uses the same logic as the one above, but instead of a rect\r\n            \/\/it draws a specified sprite frame.\r\n            if (this.rotate) {\r\n                ctx.save();\r\n                ctx.translate(this.x, this.y);\r\n                ctx.rotate(this.angle);\r\n                gameArea.context.drawImage(\r\n                        this.image, \/\/source file\r\n                        (this.index * this.srcWidth), \/\/source x\r\n                        0, \/\/source y\r\n                        this.srcWidth, \/\/sub-image width\r\n                        this.srcHeight, \/\/sub-image height\r\n                        -this.destWidth \/ 2 + this.offsetX,\r\n                        -this.destHeight \/ 2 + this.offsetY,\r\n                        this.destWidth, \/\/destination width\r\n                        this.destHeight); \/\/destination height\r\n                ctx.restore();\r\n            } else {\r\n                gameArea.context.drawImage(\r\n                        this.image, \/\/source file\r\n                        (this.index * this.srcWidth), \/\/source x\r\n                        0, \/\/source y\r\n                        this.srcWidth, \/\/sub-image width\r\n                        this.srcHeight, \/\/sub-image height\r\n                        (this.topLeftSprite().x + this.offsetX),\r\n                        (this.topLeftSprite().y + this.offsetY),\r\n                        this.destWidth, \/\/destination width\r\n                        this.destHeight); \/\/destination height\r\n            }\r\n        };\r\n        this.render = function () {\r\n            if (settings.drawBoundBoxes) {\r\n                this.drawBox();\r\n            }\r\n            if (settings.drawSprites) {\r\n                this.drawSprite();\r\n            }\r\n        };\r\n    }\r\n\/\/  this serves as the prototype for the entities on the board. It contains information \r\n\/\/  necessary to position and render the entities at various locations, orientations and so on.\r\n\/\/  ----- external methods:\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  drawSprite()    - draw sprite\r\n\/\/  render()        - draw according to config rule\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n    function playerShip(x, y, params) {\r\n        \/\/run component()\'s initialization logic - playerShip extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.image = assetPool.playerShipImg;\r\n\r\n        this.acceleration = params.acceleration;\r\n        this.maxSpeed = params.maxSpeed;\r\n        this.targetsLocked = [];\r\n\r\n        \/\/if mouse is not pressed and there are targets locked, fire a missile at and\r\n        \/\/unlock each target in sequence until no targets are locked\r\n        this.fireControl = function () {\r\n            if (!gameArea.mouseDown && this.targetsLocked.length >= 1) {\r\n                if (gameArea.frameNo % 3 === 0) {\r\n                    this.fire(this.targetsLocked[0]);\r\n                    this.targetsLocked.splice(0, 1);\r\n                }\r\n            }\r\n            ;\r\n        };\r\n\r\n        \/\/fire a missile at a target\r\n        this.fire = function (target) {\r\n            gameArea.playerMissiles.push(new playerMissile(playerShip.x, playerShip.y, playerMissileProperties, target));\r\n        };\r\n\r\n        \/\/update position with respect to user input\r\n        this.newPos = function (targetY) {\r\n            this.y += (clamp((targetY - this.y), -this.maxSpeed, this.maxSpeed)) \/ this.acceleration;\r\n        };\r\n\r\n        \/\/run necessary logic to prepare for the next frame\r\n        this.update = function () {\r\n            this.fireControl();\r\n            this.index = Math.floor(clamp(((this.y - gameArea.mouseY) \/ 13 + 15), 0, 29));\r\n        };\r\n    }\r\n\/\/  playerShip extends component. This constructs the player character.\r\n\/\/  ----- external methods:\r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  drawSprite()    - draw sprite\r\n\/\/  render()        - draw according to config rule\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n    function playerMissile(x, y, params, target) {\r\n        \/\/run component()\'s initialization logic - playerMissile extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.image = assetPool.playerMissileImg;\r\n\r\n        this.acceleration = params.acceleration;\r\n\r\n\r\n        this.velocityX;\r\n        this.velocityY;\r\n        this.thrust = params.thrust;\r\n        this.target = target;\r\n        this.target.tracked = true;\r\n        this.targetsLocked = [];\r\n\r\n        \/\/get angle to target\r\n        this.getAngle = function () {\r\n            var x = this.x - (this.target.x);\r\n            var y = this.y - (this.target.y);\r\n            this.angle = (Math.atan2(y, x)) - Math.PI;\r\n        };\r\n        \/\/update position with respect to target\r\n        this.newPos = function () {\r\n            var tx = (this.target.x) - this.x;\r\n            var ty = (this.target.y) - this.y;\r\n            var dist = Math.sqrt(tx * tx + ty * ty);\r\n\r\n            this.thrust = this.thrust + this.acceleration;\r\n\r\n            this.velocityX = (tx \/ dist) * this.thrust;\r\n            this.velocityY = (ty \/ dist) * this.thrust;\r\n\r\n            this.x += this.velocityX;\r\n            this.y += this.velocityY;\r\n        };\r\n        \/\/run necessary logic to prepare for the next frame\r\n        this.update = function () {\r\n            this.age++;\r\n            this.getAngle();\r\n            if (this.index <= 18) {\r\n                this.index++;\r\n            } else {\r\n                this.index = 1;\r\n            }\r\n            if (this.age > 75) {\r\n                this.active = false;\r\n            }\r\n            if (settings.generateSmoke) {\r\n                for (var i = 0; i <= settings.smokeFactor; i++) {\r\n                    gameArea.exhausts.push(new exhaust((Math.random() * 10) + this.x, this.y, exhaustProperties, this.angle));\r\n                }\r\n            }\r\n        };\r\n    }\r\n\/\/  playerMissile extends component. This constructs a missile object.\r\n\/\/  ----- external methods:   \r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  drawSprite()    - draw sprite\r\n\/\/  render()        - draw according to config rule\r\n\/\/  --------------------------------------------------------------------------------\r\n\r\n\r\n    function exhaust(x, y, params, angle) {\r\n        \/\/run component()\'s initialization logic - exhaust extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.radius = params.radius;\r\n        this.angle = (Math.random() * 0.25) + angle - Math.PI;\r\n        this.acceleration = params.acceleration;\r\n        this.thrust = (Math.random() * 1) + 2;\r\n        this.velocityX;\r\n        this.velocityY;\r\n        this.lifetime = Math.random() * 50 + 10;\r\n        \/\/\r\n        this.fadeEffect = function () {\r\n            this.radius = (8 * (this.age \/ this.lifetime)) + 3;\r\n            if (this.x < 0 || this.age > this.lifetime) {\r\n                this.active = false;\r\n            }\r\n        };\r\n        \/\/update position with respect to angle\r\n        this.newPos = function () {\r\n            this.thrust = this.thrust + this.acceleration;\r\n\r\n            this.velocityX = Math.cos(this.angle) * this.thrust;\r\n            this.velocityY = Math.sin(this.angle) * this.thrust;\r\n\r\n            this.x += this.velocityX - 4;\r\n            this.y += this.velocityY;\r\n        };\r\n        \/\/run necessary logic to prepare for the next frame\r\n        this.update = function () {\r\n            this.age++;\r\n            this.drawCustom();\r\n            this.fadeEffect();\r\n        };\r\n        \/\/custom draw function that draws a radial gradient with transparency \r\n        \/\/proportional to the age of the particle\r\n        this.drawCustom = function () {\r\n            ctx = gameArea.context;\r\n            ctx.globalAlpha = 1 - (this.age \/ (this.lifetime + 1));\r\n            gradient = ctx.createRadialGradient(this.x, this.y, this.radius \/ 2, this.x, this.y, this.radius);\r\n            gradient.addColorStop(0, params.color);\r\n            gradient.addColorStop(1, \'transparent\');\r\n            ctx.fillStyle = gradient;\r\n            ctx.fillRect(this.topLeftBoundary().x, this.topLeftBoundary().y, this.width, this.height);\r\n            ctx.globalAlpha = 1.0;\r\n        };\r\n    }\r\n\/\/  exhaust extends component. This constructs an exhaust object.\r\n\/\/  ----- external methods:   \r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  NB this object assumes control of its own rendering, no draw or render calls necessary\r\n\/\/  --------------------------------------------------------------------------------\r\n\r\n    function enemyBasic(x, y, params, speed) {\r\n        \/\/run component()\'s initialization logic - enemyBasic extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.image = assetPool.enemyBasicImg;\r\n\r\n        this.speed = speed;\r\n        this.locked = false;\r\n        this.tracked = false;\r\n\r\n        \/\/run necessary logic to prepare for the next frame\r\n        this.update = function () {\r\n            \/\/sprite animation loop\r\n            if (this.index <= 117) {\r\n                this.index++;\r\n            } else {\r\n                this.index = 0;\r\n            }\r\n            \/\/if object leaves left side of gameArea then self-destruct\r\n            if (this.x <= -100) {\r\n                this.active = false;\r\n            }\r\n            \/\/if touched by cursor whilst not locked, set self to locked\r\n            if (cursor.hoverEnemy === this && !this.locked) {\r\n                if (gameArea.mouseDown) {\r\n                    this.locked = true;\r\n                    playerShip.targetsLocked.push(this);\r\n                    \/\/create new crosshair over this enemyBasic with a set size\r\n                    gameArea.crosshairs.push(new crosshair(this.x, this.y, crosshairProperties, this));\r\n                }\r\n            }\r\n        };\r\n        \/\/update position\r\n        this.newPos = function () {\r\n            this.x += this.speed;\r\n        };\r\n    }\r\n\/\/  enemyBasic extends component. This object is the most basic enemy.\r\n\/\/  ----- external methods:   \r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  drawSprite()    - draw sprite\r\n\/\/  render()        - draw according to config rule\r\n\/\/  --------------------------------------------------------------------------------\r\n\r\n\r\n    function explosion(x, y, params) {\r\n        \/\/run component()\'s initialization logic - explosion extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.image = assetPool.explosionImg;\r\n\r\n        \/\/run necessary logic to prepare for the next frame\r\n        this.update = function () {\r\n            this.age++;\r\n            this.index = this.age * 2;\r\n            if (this.index > 25) {\r\n                this.active = false;\r\n            }\r\n        };\r\n    }\r\n\/\/  explosion extends component. This creates an explosion effect object.\r\n\/\/  ----- external methods:   \r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  drawSprite()    - draw sprite\r\n\/\/  render()        - draw according to config rule\r\n\/\/  --------------------------------------------------------------------------------\r\n\r\n    function explodyBit(x, y, params) {\r\n        \/\/run component()\'s initialization logic - explodyBit extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.width = Math.random() * 4;\r\n        this.height = Math.random() * 4;\r\n\r\n        this.acceleration = params.acceleration;\r\n        this.vSpeed = params.vSpeed;\r\n        this.velocityX;\r\n        this.velocityY;\r\n        this.thrust = (Math.random() * 3) + 5;\r\n        this.angle = (Math.random() * 360) - 180;\r\n        \/\/update position with respect to gravity\r\n        this.newPos = function () {\r\n            this.thrust = clamp(this.thrust + this.acceleration, 2, 100);\r\n\r\n            this.velocityX = Math.cos(this.angle) * this.thrust;\r\n            this.velocityY = Math.sin(this.angle) * this.thrust;\r\n\r\n            this.vSpeed += 0.3;\r\n\r\n            this.x += this.velocityX;\r\n            this.y += this.velocityY + this.vSpeed;\r\n        };\r\n        \/\/run necessary logic to prepare for the next frame\r\n        this.update = function () {\r\n            this.age++;\r\n            this.drawBox();\r\n            if (this.age > 150) {\r\n                this.active = false;\r\n            }\r\n        };\r\n    }\r\n\/\/  explodyBit extends component. This creates a shrapnel object.\r\n\/\/  ----- external methods:   \r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  NB this object assumes control of its own rendering, no draw or render calls necessary\r\n\/\/  --------------------------------------------------------------------------------\r\n\r\n\r\n    function cursor(x, y, params) {\r\n        \/\/run component()\'s initialization logic - cursor extends component\r\n        component.call(this, x, y, params);\r\n\r\n        this.image = assetPool.cursorImg;\r\n\r\n        this.visible = true;\r\n        this.hoverEnemy = false;\r\n\r\n        \/\/update position with respect to user input\r\n        this.newPos = function () {\r\n            this.x = gameArea.mouseX;\r\n            this.y = gameArea.mouseY;\r\n        };\r\n        this.update = function () {\r\n            if (gameArea.mouseDown) {\r\n                \/\/sprite animation increments to maximum and holds if mouseDown\r\n                if (this.index < 10) {\r\n                    this.index += 2;\r\n                } else {\r\n                    this.index = 10;\r\n                }\r\n            } else if (this.index > 0) {\r\n                \/\/else decrements to minimum and holds if !mouseDown\r\n                this.index -= 2;\r\n            } else {\r\n                this.index = 0;\r\n            }\r\n\r\n            if (this.visible) {\r\n                this.width = params.widthMouse;\r\n                this.height = params.heightMouse;\r\n                this.drawSprite();\r\n            } else {\r\n                this.width = params.widthTouch;\r\n                this.height = params.heightTouch;\r\n            }\r\n        };\r\n    }\r\n\/\/  cursor extends component. This constructs the cursor object.\r\n\/\/  external methods:\r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  render()        - draw according to config rule\r\n\/\/  NB this object assumes control of its own sprite drawing, no drawSprite() call necessary\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n    function crosshair(x, y, params, parent) {\r\n        \/\/run component()\'s initialization logic - cursor extends component\r\n        component.call(this, x, y, params);\r\n\r\n        \/\/the size to shrink to\r\n        this.minSize = params.minSize;\r\n\r\n        \/\/object this crosshair is slaved to\r\n        this.parent = parent;\r\n\r\n        \/\/toggle the box color at a regular interval if at min size\r\n        this.flashLockBox = function () {\r\n            this.angle = 0;\r\n            if (this.age % 4 === 0 && this.width <= this.minSize) {\r\n                if (this.color === \'red\') {\r\n                    this.color = \'transparent\';\r\n                } else {\r\n                    this.color = \'red\';\r\n                }\r\n            }\r\n        };\r\n        \/\/update position based on parent\r\n        this.newPos = function () {\r\n            this.x = this.parent.x;\r\n            this.y = this.parent.y;\r\n        };\r\n        \/\/custom draw function using stroke. Prototype uses rect\r\n        this.drawCustom = function () {\r\n            ctx = gameArea.context;\r\n            ctx.save();\r\n            ctx.translate(this.parent.x, this.parent.y);\r\n            ctx.rotate(this.angle);\r\n            ctx.strokeStyle = this.color;\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeRect(0 - this.width \/ 2, 0 - this.width \/ 2, this.width, this.height);\r\n            ctx.restore();\r\n        };\r\n        this.update = function () {\r\n            this.age++;\r\n\r\n            if (this.width > this.minSize & this.age > 5) {\r\n                \/\/if crosshair has existed for a set time and is above a set size, begin shrinking\r\n                this.width -= 10;\r\n                this.height -= 10;\r\n            }\r\n            if (!this.parent.tracked) {\r\n                \/\/if not tracked by missile, rotate red\r\n                this.color = \'#005500\';\r\n                this.angle -= 0.1;\r\n            } else {\r\n                this.flashLockBox();\r\n            }\r\n            \/\/custom draw function uses stroke\r\n            this.drawCustom();\r\n            \/\/existence is tied to the parent\r\n            if (!this.parent.active) {\r\n                this.active = false;\r\n            }\r\n        };\r\n    }\r\n\/\/  crosshair extends component. This constructs crosshair objects.\r\n\/\/  external methods:\r\n\/\/  newPos()        - update position\r\n\/\/  update()        - controller that prepares for next frame and draws object\r\n\/\/  drawBox()       - draw bounding box\r\n\/\/  NB this object assumes control of its own canvas based drawing, no draw calls necessary\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n\r\n\/\/  UTILITY FUNCTIONS  =============================================================\r\n\r\n    function clamp(num, min, max) {\r\n        return num <= min ? min : num >= max ? max : num;\r\n    }\r\n\/\/  this function clamps the first argument using the second and third arguments as\r\n\/\/  minimum and maximum values respectively\r\n\/\/  --------------------------------------------------------------------------------   \r\n\r\n\r\n    function collision(a, b) {\r\n        return a.topLeftBoundary().x < b.topLeftBoundary().x + b.width &&\r\n                a.topLeftBoundary().x + a.width > b.topLeftBoundary().x &&\r\n                a.topLeftBoundary().y < b.topLeftBoundary().y + b.height &&\r\n                a.topLeftBoundary().y + a.height > b.topLeftBoundary().y;\r\n    }\r\n\/\/  this function checks the positions and dimensions of two objects for overlap\r\n\/\/  --------------------------------------------------------------------------------   \r\n\r\n\r\n    function collisionHandler() {\r\n        cursor.hoverEnemy = null;\r\n        \/\/consequences of enemyBasics colliding with other objects\r\n        $(gameArea.enemies).each(function () {\r\n            enemy = this;\r\n            \/\/with playerShip\r\n            if (collision(playerShip, enemy)) {\r\n                gameArea.score = \"FAILED AT \" + gameArea.score + \' - CLICK TO RESTART\';\r\n                gameArea.stop();\r\n            }\r\n            \/\/with cursor\r\n            if (collision(cursor, enemy)) {\r\n                cursor.hoverEnemy = enemy;\r\n            }\r\n        });\r\n        \/\/consequences of playerMissiles colliding with their targets\r\n        $(gameArea.playerMissiles).each(function () {\r\n            if (collision(this.target, this)) {\r\n                gameArea.score += 10;\r\n                this.target.active = false;\r\n                this.active = false;\r\n                if (settings.generateShrapnel) {\r\n                    for (var i = 0; i < settings.shrapnelFactor; i++) {\r\n                        gameArea.explodyBits.push(new explodyBit(this.x, this.y, explodyBitProperties));\r\n                    }\r\n                }\r\n                if (settings.generateExplosions) {\r\n                    gameArea.explosions.push(new explosion(this.target.x, this.target.y, explosionProperties));\r\n                }\r\n            }\r\n        });\r\n    }\r\n\/\/ this function describes the events to be carried out in the case of a collision between\r\n\/\/ various objects\r\n\/\/  --------------------------------------------------------------------------------    \r\n\r\n\r\n\r\n\/\/  THE LOOP #######################################################################\r\n\r\n    function updateGameArea() {\r\n        gameArea.clear();\r\n        gameArea.frameNo++;\r\n\r\n        \/\/BACKGROUND ===============================================================\r\n        if (settings.drawBg) {\r\n            gameArea.background();\r\n        }\r\n\r\n        \/\/EXHAUST SMOKE ============================================================\r\n        \/\/filter exhaust\r\n        if (settings.generateSmoke) {\r\n            gameArea.exhausts = gameArea.exhausts.filter(function (exhaust) {\r\n                return exhaust.active;\r\n            });\r\n            \/\/update exhaust\r\n            $(gameArea.exhausts).each(function () {\r\n                this.newPos();\r\n                this.update();\r\n            });\r\n        }\r\n\r\n        \/\/PLAYERMISSILES ===========================================================\r\n        \/\/filter missiles\r\n        gameArea.playerMissiles = gameArea.playerMissiles.filter(function (playerMissile) {\r\n            return playerMissile.active;\r\n        });\r\n        \/\/update and render missiles\r\n        $(gameArea.playerMissiles).each(function () {\r\n            this.newPos();\r\n            this.update();\r\n            this.render();\r\n        });\r\n\r\n        \/\/ENEMIES ==================================================================\r\n        \/\/filter enemies\r\n        gameArea.enemies = gameArea.enemies.filter(function (enemyBasic) {\r\n            return enemyBasic.active;\r\n        });\r\n        \/\/spawn enemies\r\n        if ((Math.random() * 1000) > (990 - gameArea.frameNo \/ 100)) {\r\n            gameArea.enemies.push(new enemyBasic(490, (Math.random() * (settings.canvasHeight - 50) + 25), enemyBasicProperties, (Math.random() * -1.5 - 1)));\r\n        }\r\n        \/\/update and render enemies\r\n        $(gameArea.enemies).each(function () {\r\n            this.newPos();\r\n            this.update();\r\n            this.render();\r\n        });\r\n\r\n        \/\/EXPLOSIONS ===============================================================\r\n        \/\/filter explosions\r\n        gameArea.explosions = gameArea.explosions.filter(function (explosion) {\r\n            return explosion.active;\r\n        });\r\n        \/\/update and render explosions\r\n        $(gameArea.explosions).each(function () {\r\n            this.update();\r\n            this.render();\r\n        });\r\n\r\n        \/\/EXPLODY BITS =============================================================\r\n        \/\/filter bits\r\n        gameArea.explodyBits = gameArea.explodyBits.filter(function (explodyBit) {\r\n            return explodyBit.active;\r\n        });\r\n        \/\/update bits\r\n        $(gameArea.explodyBits).each(function () {\r\n            this.newPos();\r\n            this.update();\r\n        });\r\n\r\n        \/\/PLAYER SHIP ==============================================================\r\n        playerShip.update();\r\n        playerShip.newPos(gameArea.mouseY);\r\n        playerShip.render();\r\n\r\n        \/\/CROSSHAIRS ===============================================================\r\n        \/\/filter crosshairs\r\n        gameArea.crosshairs = gameArea.crosshairs.filter(function (crosshair) {\r\n            return crosshair.active;\r\n        });\r\n        \/\/update crosshairs (they are self rendering)\r\n        $(gameArea.crosshairs).each(function () {\r\n            this.newPos();\r\n            this.update();\r\n        });\r\n\r\n        \/\/CURSOR ===================================================================\r\n        cursor.update();\r\n        cursor.newPos();\r\n\r\n        \/\/Utilities ================================================================\r\n        collisionHandler();\r\n        gameArea.updateScore();\r\n    }\r\n\/\/  --------------------------------------------------------------------------------    \r\n})();','javascript'];

//########## INIT EDITORS ##########//

    //Get all editors on the page
    var editors = $(".editor");
    //Initialise all editors on the page with theme, mode and contents
    $(editors).each(function () {
        //Get individual editor
        var editorId = $(this).attr('id');
        var editor = ace.edit(editorId);
        //Set parameters
        editor.setTheme("ace/theme/monokai");
//        editor.setReadOnly(true);
        editor.setOptions({
            maxLines: 30
        });
        //Get editor number
        editorNumber = parseInt($(this).attr('id').match(/\d+/g) - 1);
        //If an entry exists, apply it to the editor, else throw an error
        if (contents[editorNumber]) {
            //Load contents
            editor.setValue(contents[editorNumber][0]);
            //Load mode
            editor.getSession().setMode("ace/mode/" + contents[editorNumber][1]);
        } else {
            console.log('No contents specified for editor #' + parseInt(editorNumber + 1));
        }
    });
});
