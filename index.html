<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html lang="en">

<head>
  <link
    href="https://fonts.googleapis.com/css?family=Arsenal"
    rel="stylesheet">
  <link rel="stylesheet"
    href="./css/stylesheet.css" type="text/css">
  <title>Simple Javascript Game Development
  </title>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <script
    src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/ace/1.2.6/min/ace.js"></script>
</head>

<body>
  <header id="header">
    <h1 class="page-heading">Simple Javascript
      Game Development</h1>
  </header>
  <div id="main-container">
    <div id="scroller">
    </div>
    <div id="content-container">
      <div class="dotted-line"></div>
      <section id="section-1"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">function
            startGame()</p>
        </div>
        <div class="parallax">
          <p class="background-floater">
            this.canvas.getContext("2d);");</p>
        </div>
        <h2 id="step-heading-1"
          class="step-heading">1. In the
          Beginning...</h2>
        <div class="step-container">
          <div class="step__left">
            <p>For anything to be able to happen,
              there needs to be a space in which
              it can happen. We must create the
              world in which the events that drive
              the game will take place.<br><br>
              Both the space itself, an html5
              canvas element, and a javascript
              object myGameArea must be created
              that describes this space. This
              object has a method start(), and
              that method, when executed,
              takes the space and assigns it
              values describing it's dimensions.
              There must also be a function
              starGame() that will set the process
              of
              initializing the game in
              motion.<br><br>It is within this
              space, now stored by myGameArea,
              that the game will take
              place.<br><br></p>
          </div>
          <div class="step__right">
            <div><img id="step-button-1"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-1"><iframe
                id="iframe-1"
                class='right__canvas'
                src="./web/step-1.html"></iframe>
            </div>
            <div id="editor-1" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-2"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            canvas.width = 480;</p>
        </div>
        <div class="parallax">
          <p class="background-floater">ctx =
            myGameArea.context;</p>
        </div>
        <h2 id="step-heading-2"
          class="step-heading">2. The Avatar</h2>
        <div class="step-container">
          <div class="step__left">
            <p>The first thing to be added to the
              game is the player avatar. This
              entity is a representation of the
              players agency, through the control
              of which the player
              will be able to interface with the
              game world. It is fitting that it is
              the first entity to populate the
              game world.
              <br><br>A new function,
              'component()', has been added. It is
              a constructor function that
              specifies a template that can be
              used to instantiate objects.
              A new line in the startGame()
              function uses component() to create
              a new instance of itself with a
              particular set of values,
              essentially creating a new
              component named myGamePiece() on the
              canvas.</p>
          </div>
          <div class="step__right">
            <div><img id="step-button-2"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-2"><iframe
                id="iframe-2"
                class='right__canvas'
                src="./web/step-2.html"></iframe>
            </div>
            <div id="editor-2" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-3"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            setInterval(updateGameArea, 20);</p>
        </div>
        <div class="parallax">
          <p class="background-floater">clear :
            function() {</p>
        </div>
        <h2 id="step-heading-3"
          class="step-heading">3. The Passage of
          Time</h2>
        <div class="step-container">
          <div class="step__left">
            <p>For events to occur, there must be
              the passage of time. The game area
              must update itself in order for
              things to progress. To do this, an
              interval
              must be specified that governs how
              many times a second the display is
              updated.<br><br>myGameArea() has had
              a new property
              added to its start method called
              interval. This specifies what
              function to execute at what
              frequency. The function to be called
              is a new function
              called updateGameArea() that
              currently does two things:
              myGameArea.clear() and
              myGamePiece.update().<br><br>clear()
              has
              been added to myGameArea() and when
              called, clears the display. update()
              has been added to the component
              constructor so when myGamePiece is
              created via this constructor it will
              have update() as a method. The logic
              that determines the position and
              appearance of myGamePiece
              is now contained in this method and
              is updated when the method is
              called.<br><br>Now every frame the
              game area clears and the game piece
              redraws itself based on its current
              properties.</p>
          </div>
          <div class="step__right">
            <div><img id="step-button-3"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-3"><iframe
                id="iframe-3"
                class='right__canvas'
                src="./web/step-3.html"></iframe>
            </div>
            <div id="editor-3" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-4"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">start:
            function ()</p>
        </div>
        <div class="parallax">
          <p class="background-floater">clear:
            function ()</p>
        </div>
        <h2 id="step-heading-4"
          class="step-heading">4. Summary - The
          Board is Set</h2>
        <div class="step-container">
          <div class="step__left">
            <p>Now the fundamentals of a game
              environment have been established. A
              game area myGameArea() exists that
              can be drawn on and cleared
              that has a set interval.<br><br>A
              function updateGameArea() exists
              that governs what is to happen each
              interval.<br><br>A constructor
              function
              component() exists that can create a
              component with dimension and
              position data and a method that can
              update this data.<br><br>And finally
              there is
              a function startGame() that starts
              the game and creates a component
              called myGamePiece.<br><br>All the
              things that are needed for events
              and actions to occur are in
              place, all that remains is to
              provide the means to invoke them.
            </p>
          </div>
          <div class="step__right">
            <div id="editor-4" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-5"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            myGameArea.mouseX;</p>
        </div>
        <div class="parallax">
          <p class="background-floater"> =
            event.offsetY;</p>
        </div>
        <h2 id="step-heading-5"
          class="step-heading">5. Reaching into
          the World</h2>
        <div class="step-container">
          <div class="step__left">
            <p>Now that we have a world in which
              objects can be created and time
              passes, it is time to begin adding
              functionality to the game itself.
              The first logical step is to enable
              the user to move the
              avatar.<br><br>For this game the
              game piece should follow the mouse
              cursor or, if
              on a touch screen, the users finger
              press. This can be achieved by
              modifying the piece's current
              position
              by a certain amount on based on the
              position of the cursor each frame.
              The simplest way to implement this
              is by taking the cursor position
              each frame and setting the piece's
              position to match that. For that to
              happen the game piece needs a method
              that changes the piece's position
              data each frame.<br><br>newPos() has
              been added to the component
              constructor. This method takes an x
              and a y coordinate and updates the
              components position values. The
              coordinates are retrieved using an
              event listener. New code has been
              added to the start method
              of the game area. On start, an event
              listener that fires on mouse move
              retrieves the coordinates and stores
              them in the properties
              of the game area.<br><br>The player
              can now reach into the world and
              have their presence felt.</p>
          </div>
          <div class="step__right">
            <div><img id="step-button-5"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-5"><iframe
                id="iframe-5"
                class='right__canvas'
                src="./web/step-5.html"></iframe>
            </div>
            <div id="editor-5" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-6"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            this.acceleration = accel;</p>
        </div>
        <div class="parallax">
          <p class="background-floater">
            this.maxSpeed = speed;</p>
        </div>
        <h2 id="step-heading-6"
          class="step-heading">6. Structure</h2>
        <div class="step-container">
          <div class="step__left">
            <p>Whilst in the previous example the
              game piece is essentially teleported
              to the cursor each frame, giving the
              player unlimited freedom, some
              restriction is required to
              achieve a structured and meaningful
              existence. To achieve this, several
              new lines of code have been
              added, including a new function
              called clamp(). This function
              clamp() takes three numbers. The
              second and third numbers passed are
              used to clamp
              the first number passed, that is to
              say that the first number cannot go
              below the second, nor above the
              third. This function constrains a
              number to an upper and
              lower limit.
              <br><br>In order to get the game
              piece moving smoothly and with
              easing, the newPos() method was
              modified.
              The fundamental principle behind the
              movement is: y += (targetY - y) /
              speed; This statement increments the
              y value of the game piece
              by the difference between the target
              and the piece's current position,
              which is then adjusted by the speed
              parameter. The further away the
              piece is from the cursor, the larger
              the increment and therefore the
              faster the piece appears to move.
              The clamp() function is applied to
              the difference to cap the top speed
              of the
              game piece so that it moves more
              controllably. This allows
              acceleration and top speed to be
              modified separately. The speed and
              acceleration are passed to the
              component when it is called by
              startGame().</p>
          </div>
          <div class="step__right">
            <div><img id="step-button-6"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-6"><iframe
                id="iframe-6"
                class='right__canvas'
                src="./web/step-6.html"></iframe>
            </div>
            <div id="editor-6" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-7"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            this.active = true;</p>
        </div>
        <div class="parallax">
          <p class="background-floater">new
            enemyBasic()</p>
        </div>
        <div class="parallax">
          <p class="background-floater">if
            (enemyPiece.active)</p>
        </div>
        <h2 id="step-heading-7"
          class="step-heading">7. Adversity</h2>
        <div class="step-container">
          <div class="step__left">
            <p>The game world is meaningless
              without a motivating factor. The
              presence of an adversary will
              provide that motivation.<br><br>
              The component constructor has been
              split onto two separate
              constructors. One creates the player
              avatar, the other creates a new
              component called enemyBasic
              with a different set of properties.
              These properties mean the enemyBasic
              travels automatically in a straight
              line towards the left, then sets
              itself to inactive.
              A new piece of code has a chance to
              create an enemyBasic at a random
              point on the right edge of the
              world.
              An accompanying block of code checks
              the enenmyBasic to see if it is
              active before updating and redrawing
              it.
              Because the code that creates an
              enemyBasic overwrites the existing
              enemyBasic, only one can exist at
              any given time. The game world has
              no way of keeping track of more than
              one
              instance name enemyPiece.
              <br><br>Now there exists a foreign
              entity that acts on it's own accord
              and will form the basis for the
              conflict in the game.
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-7"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-7"><iframe
                id="iframe-7"
                class='right__canvas'
                src="./web/step-7.html"></iframe>
            </div>
            <div id="editor-7" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-8"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            filter(function(enemyBasic)</p>
        </div>
        <div class="parallax">
          <p class="background-floater">if
            ((Math.random() * 1000) > 990)</p>
        </div>
        <h2 id="step-heading-8"
          class="step-heading">8. Enemies</h2>
        <div class="step-container">
          <div class="step__left">
            <p>The game world must be upgraded.
              The enemyBasic must be able to
              co-exist with itself. To achieve
              this, the world must store a list of
              enemyBasics, each a unique instance
              of the constructor.
              An array in myGameArea must be
              created, and the code that creates
              new enemyBasics must append these
              new entities to this list. In such a
              way, multiple unique enemyBasics are
              able to exist side by side.
              <br><br>However, there is a problem.
              Each new enemyBasic leads to a new
              entry in the list, which will keep
              growing forever. An additional piece
              of code must also be created that
              checks for inactive enemyBasics
              and removes them. The filter method
              will achieve this goal.
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-8"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-8"><iframe
                id="iframe-8"
                class='right__canvas'
                src="./web/step-8.html"></iframe>
            </div>
            <div id="editor-8" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-9"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">function
            collision(a, b)</p>
        </div>
        <div class="parallax">
          <p class="background-floater">function
            collisionHandler()</p>
        </div>
        <div class="parallax">
          <p class="background-floater">
            myGameArea.stop();</p>
        </div>
        <h2 id="step-heading-9"
          class="step-heading">9. First Contact
        </h2>
        <div class="step-container">
          <div class="step__left">
            <p>Now the entites must be able to
              interact with each other. A function
              collision() must be created that can
              discern if two given entities are
              intersecting.
              Another function collisionHandler()
              then decides what to do with that
              information. In this case, if an
              enemyBasic touches the player
              avatar, the game stops.
              This is achieved by using a function
              that clears the interval that
              dictates the rate of the passage of
              time.
              <br><br>The function that is used to
              stop time can also be invoked when
              the player clicks outside of the
              world. This means that if they move
              their attention away from the game,
              it waits in a frozen state for the
              player to return. click and blur
              listeners working in tandem to set
              and unset the interval can achieve
              the desired effect.
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-9"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-9"><iframe
                id="iframe-9"
                class='right__canvas'
                src="./web/step-9.html"></iframe>
            </div>
            <div id="editor-9" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-10"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">if (this.x
            &= 0) {</p>
        </div>
        <div class="parallax">
          <p class="background-floater">this.x +=
            -3;</p>
        </div>
        <div class="parallax">
          <p class="background-floater">this.x =
            x;</p>
        </div>
        <h2 id="step-heading-10"
          class="step-heading">10. Summary - The
          Pieces are Moving</h2>
        <div class="step-container">
          <div class="step__left">
            <p>The world is now alive. This is a
              game. The player avatar can be
              manipulated, and must do so to avoid
              the enemyBasics that are
              relentlessly spawned and will end
              the game if the collide with the
              avatar.
              <br><br>This is a game at the most
              basic level. The following steps are
              enhancements on the core
              functionality that serve to make the
              world more interesting and the game
              more exciting.
            </p>
          </div>
          <div class="step__right">
            <div id="editor-10" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-11"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">function
            playerMissile()</p>
        </div>
        <div class="parallax">
          <p class="background-floater">
            this.active = false;</p>
        </div>
        <div class="parallax">
          <p class="background-floater">
            $(myGameArea.playerMissiles)</p>
        </div>
        <h2 id="step-heading-11"
          class="step-heading">11. The Player
          Strikes Back</h2>
        <div class="step-container">
          <div class="step__left">
            <p>Now that the enemies pose an actual
              hazard, the player needs a means to
              actually fight back. Dodging the
              enemies could make for a game all on
              its own
              but the ability to fight back makes
              things more interesting. A new
              component playerMissile() has been
              added. Player missile is an object
              that is created on
              click and travels towards the click
              location upon which it sets itself
              to inactive and is removed. If it
              collides with an enemy it sets both
              itself and the enemy
              to inactive, removing
              both.<br><br>The missile object
              accelerates towards
              the target location using a block of
              code to determine the amount its x
              and y
              values need to be changed to step
              towards the target. This is further
              modified by
              an acceleration value that changes
              the magnitude of each step over
              time.
              <br><br>
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-11"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-11"><iframe
                id="iframe-11"
                class='right__canvas'
                src="./web/step-11.html"></iframe>
            </div>
            <div id="editor-11" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-12"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">if
            (mouseOver(this) && !this.targeted) {
          </p>
        </div>
        <div class="parallax">
          <p class="background-floater">
            Math.atan2(y,x)</p>
        </div>
        <div class="parallax">
          <p class="background-floater"></p>
        </div>
        <h2 id="step-heading-12"
          class="step-heading">Step 12: Refined
          Mechanics</h2>
        <div class="step-container">
          <div class="step__left">
            <p>An advanced gameplay mechanic has
              been added. Missiles now cannot be
              dumbfired. Instead, when the cursor
              passes over an enemey whilst a mouse
              button
              is pressed down, that enemy and any
              others the cursor passes over will
              be appended to an array and
              highlighted to indicate it is locked
              on.
              Upon release of the button, the list
              is looped through, and a barrage of
              missiles is fired, one per target.
              Two mouse event listeners were added
              that account for presses and
              releases of mouse buttons.
              Missiles will only collide and
              mutually deactivate their designated
              target. The missiles target location
              is now the location of the target at
              each given moment, meaning
              missiles will home in on their
              designated target. <br><br>This
              means that each missile is created
              for a specific target which the
              missile travels towards and
              destroys, or if
              for some reason it does not reach
              its target in time it self
              destructs. This game mechanic adds
              some structure to the combat in the
              game, making things a bit more
              interesting
              than just random clicking to spam as
              many missiles as possible.
              <br><br>
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-12"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-12"><iframe
                id="iframe-12"
                class='right__canvas'
                src="./web/step-12.html"></iframe>
            </div>
            <div id="editor-12" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-13"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            Math.cos(radians)</p>
        </div>
        <div class="parallax">
          <p class="background-floater">radians =
            Math.atan2(y,x);</p>
        </div>
        <div class="parallax">
          <p class="background-floater"></p>
        </div>
        <h2 id="step-heading-13"
          class="step-heading">Step 13: Icing on
          the Cake</h2>
        <div class="step-container">
          <div class="step__left">
            <p>Three important changes have been
              made here. Missiles now orient
              themselves to point towards the
              target they are tracking. This is
              achieved by
              temporarily moving the canvas to the
              missiles location, rotating it,
              drawing the missile and then
              reverting the canvas back to its
              default
              position, leaving the rotated
              missile in place.<br><br>Missiles
              now emit exhaust objects which have
              the missile orientation passed to
              them.
              They use this information to move in
              the opposite direction to simulate
              the exhaust plume of a missile in
              flight. These objects become
              transparent over
              time by temporarily changing the
              opacity of the canvas before drawing
              themselves and then
              reverting.<br><br>Finally, a lock on
              effect has been added
              that uses a rectangular stroke to
              draw and animate a crosshair over
              locked targets. This crosshair has
              three stages which change to reflect
              whether a target is locked and
              awaiting a missile fire event, or
              has a missile actively tracking it.
              The first stage is the initial lock
              effect, where the crosshair appears
              and then
              proceeds to shrink down. It then
              settles to a minimum size and
              rotates about the target to indicate
              the target is locked. Finally, the
              third mode triggers once a missile
              is actively tracking the target. The
              corsshair flashes red to indicate a
              missile is en route. This serves to
              make the act of targeting more
              visually interesting and more
              explicit
              and obvious.
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-13"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-13"><iframe
                id="iframe-13"
                class='right__canvas'
                src="./web/step-13.html"></iframe>
            </div>
            <div id="editor-13" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-14"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            Math.cos(radians)</p>
        </div>
        <div class="parallax">
          <p class="background-floater">radians =
            Math.atan2(y,x);</p>
        </div>
        <div class="parallax">
          <p class="background-floater"></p>
        </div>
        <h2 id="step-heading-14"
          class="step-heading">Step 14: Let there
          be Sprites</h2>
        <div class="step-container">
          <div class="step__left">
            <p>These arbitrary representations are
              not particularly interesting to look
              at. For the entities to be
              reasonably
              compelling representations of the
              subject matter they must actually
              resemble the objects they
              represent.<br><br>
              Functionality for the display of
              sprites has been added. Each entity
              that is to have a sprite now has a
              sprite sheet
              and the information used to handle
              the sprite sheet as part of its
              properties. The drawImage() function
              is
              critical, as it allows a specific
              portion of an image to be drawn at a
              specific place. By using logic to
              determine the
              position of an individual sprite on
              a sheet, the index value can
              determine which frame is drawn. By
              modifying index, the
              frame can be modified.<br><br>The
              missile exhaust is still a canvas
              rect, but has no been upgraded to
              use a radial gradient to look more
              smoky. A cursor sprite has also been
              added that expands on click and
              returns when click is released.
              This should serve to clarify the
              click and drag targeting mechanic a
              bit better. Finally, a background
              image that is tiled
              has been set to scroll a set
              distance before returning to the
              beginning in such a was so as to
              appear seamless.
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-14"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-14"><iframe
                id="iframe-14"
                class='right__canvas'
                src="./web/step-14.html"></iframe>
            </div>
            <div id="editor-14" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-15"
        class="section-container">
        <div class="parallax">
          <p class="background-floater">
            Math.cos(radians)</p>
        </div>
        <div class="parallax">
          <p class="background-floater">radians =
            Math.atan2(y,x);</p>
        </div>
        <div class="parallax">
          <p class="background-floater"></p>
        </div>
        <h2 id="step-heading-15"
          class="step-heading">Step 15: Push Me,
          and then just Touch Me</h2>
        <div class="step-container">
          <div class="step__left">
            <p>As this game is intended to be able
              to run on mobile devices as well as
              on desktops, touch functionality is
              required.
              Much as the user clicks and drags
              over enemies to target them and move
              the ship, the user should be able to
              touch and drag
              to do the same. In order to achieve
              this the mouse functionality must be
              complemented with touch
              functionality.<br><br>
              Event listeners for the tap,
              touchstart, touchend and touchmove
              events have been added in order to
              replicate this functionality.
              As a part of upgrading the user
              input code, the logic has been made
              more modular and uses a more robust
              method of finding the
              cursor position. Instead of simply
              using the mouse offset, the
              getBoundingClientRect() method is
              used to determine the cursors
              left and top values in relation to
              the top left of the canvas bounding
              rectangle. This ensures the code is
              independent of any
              positioning quirks the canvas may be
              subject to.<br><br>Finally, a
              workaround that prevents the browser
              pausing on a tap event to
              see if the tap will be a doubletap
              has been implemented. By including
              &lt;meta name=&quot;viewport&quot;
              content=&quot;width=device
              -width, initial-scale=1.0,
              maximum-scale=1.0,
              user-scalable=0&quot;&gt; the
              browser will not pause and wait but
              instead will immediately
              execute a touch event on tap.
            </p>
          </div>
          <div class="step__right">
            <div><img id="step-button-15"
                class="modal-button"
                src="./img/playbutton.png"
                alt="expand-example"></div>
            <div id="iframe-container-15"><iframe
                id="iframe-15"
                class='right__canvas'
                src="./web/step-15.html"></iframe>
            </div>
            <div id="editor-15" class="editor">
            </div>
          </div>
        </div>
      </section>
      <section id="section-16"
        class="section-container">
        <h2 id="step-heading-16"
          class="step-heading">Refined and Ready
        </h2>
        <div class="step-container">
          <div class="step__left"
            style='width: 80%;'>
            <p>Having now reached what could be
              called the foundation for a complete
              game, it is time to review the code.
              This final step is the result of
              refactoring the entire code with the
              intention of organising and cleaning
              it up.
              The final version currently includes
              these new features:<br><br>
              The entire code has been refactored
              to use object inheritance to make it
              more modular and less redundant. All
              game objects now have a prototypical
              'component' object that gives them
              the basic traits of a game element,
              which can then be extended with
              entity specific
              functionality.<br><br>
              The code is now clearly commented
              and self documenting. It is very
              clearly organised and designed with
              further expansion in mind. Whilst
              the work up until
              now has been a progressive, organic
              process, this version of the code
              has been written retroactively, and
              in doing so minimises clutter and
              redundancy.<br><br>
              A basic resource manager has been
              added that handles the loading of
              assets and displays a loading
              screen. Previously the game would
              start as soon
              as it was clicked on and only then
              would begin loading in assets,
              leading to a period where certain
              entities are invisible. The resource
              manager
              ensures all assets are loaded before
              launching the game.<br><br>The
              exhaust sprites have been replaced
              with a stroke to improve performance
              until a more efficient
              solution is found.<br><br>

            </p>
            <a class="page-heading"
              href="./web/feature.html">Click Here
              To See The 'Finished' Product</a>
            <div id="editor-16"
              class="editor editor-final"></div>
          </div>
        </div>
      </section>
    </div>
  </div>
  <script src="./js/main.js"></script>
  <script src="./js/game.js"></script>
</body>

</html>